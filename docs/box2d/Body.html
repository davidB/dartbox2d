        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Body class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="Body">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/Body.html">Body</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Body</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Body {
 /** Flags for different states the body can take on. */
 static const int ISLAND_FLAG = 0x0001;
 static const int AWAKE_FLAG = 0x0002;
 static const int AUTO_SLEEP_FLAG = 0x0004;
 static const int BULLET_FLAG = 0x0008;
 static const int FIXED_ROTATION_FLAG = 0x0010;
 static const int ACTIVE_FLAG = 0x0020;
 static const int TO_I_FLAG = 0x0040;

 World world;

 int flags;

 ContactEdge contactList;

 num sleepTime;

 /** User can store what they want in here. */
 dynamic userData;

 /** The linear velocity of this body. */
 final vec2 _linearVelocity;

 /** The angular velocity of this body. */
 num _angularVelocity;

 /** This body's mass. */
 num mass;

 /** The inverse of the body mass. */
 num invMass;

 /** For mantaining the linked list of bodies. */
 Body next;
 Body prev;

 Fixture fixtureList;
 int fixtureCount;

 JointEdge jointList;

 /** Forces applied on the body. */
 final vec2 _force;

 num _torque;

 /** Rotational intertia about the center of mass. */
 num _inertia;

 /** The inverse of the intertia about the center of mass. */
 num invInertia;

 num linearDamping;

 num angularDamping;

 /** This body's type. See BodyType.dart. */
 int _type;

 int islandIndex;

 /** The body origin transform. */
 final Transform originTransform;

 /** The swept motion for CCD. */
 final Sweep sweep;

 /** Private pool of objects for internal use. */
 FixtureDef _fixDef;
 MassData _pmd;
 Transform _pxf;
 vec2 oldCenter;
 vec2 tempCenter;

 Body(BodyDef bd, this.world)
     : flags = 0,
       // Set the origin transform.
       originTransform = new Transform(),

       // Set the sweep.
       sweep = new Sweep(),

       jointList = null,
       contactList = null,
       prev = null,
       next = null,

       // Set the linear and angular velocities.
       _linearVelocity = new vec2.copy(bd.linearVelocity),
       _angularVelocity = 0,

       // Set the linear and angular damping.
       linearDamping = bd.linearDamping,
       angularDamping = bd.angularDamping,

       // Set force and torque.
       _force = new vec2.zero(),
       _torque = 0,

       _inertia = 0,
       invInertia = 0,

       userData = bd.userData,

       fixtureList = null,
       fixtureCount = 0,

       // Initialize pool objects.
       _fixDef = new FixtureDef(),
       _pmd = new MassData(),
       _pxf = new Transform(),
       oldCenter = new vec2.zero(),
       tempCenter = new vec2.zero(),

       sleepTime = 0,

       _type = bd.type {
   if (bd.bullet) {
     flags |= BULLET_FLAG;
   }
   if (bd.fixedRotation) {
     flags |= FIXED_ROTATION_FLAG;
   }
   if (bd.allowSleep) {
     flags |= AUTO_SLEEP_FLAG;
   }
   if (bd.awake) {
     flags |= AWAKE_FLAG;
   }
   if (bd.active) {
     flags |= ACTIVE_FLAG;
   }

   originTransform.position.copyFrom(bd.position);
   originTransform.rotation.setRotation(bd.angle);
   sweep.localCenter.splat(0.0);
   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.copyFrom(sweep.centerZero);
   sweep.angle = bd.angle;
   sweep.angleZero = bd.angle;

   if (_type == BodyType.DYNAMIC) {
     mass = 1;
     invMass = 1;
   } else {
     mass = 0;
     invMass = 0;
   }
 }

 /**
  * Creates a fixture and attach it to this body. Use this function if you need
  * to set some fixture parameters, like friction. Otherwise you can create the
  * fixture directly from a shape.
  * If the density is non-zero, this function automatically updates the mass
  * of the body.
  * Contacts are not created until the next time step.
  */
 Fixture createFixture(FixtureDef def) {
   assert (world.locked == false);

   Fixture fixture = new Fixture();
   fixture.create(this, def);

   if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
     BroadPhase broadPhase = world._contactManager.broadPhase;
     fixture.createProxy(broadPhase, originTransform);
   }

   fixture.next = fixtureList;
   fixtureList = fixture;
   ++fixtureCount;

   fixture.body = this;

   // Adjust mass properties if needed.
   if (fixture.density &gt; 0.0) {
     resetMassData();
   }

   // Let the world know we have a new fixture. This will cause new contacts
   // to be created at the beginning of the next time step.
   world._flags |= World.NEW_FIXTURE;

   return fixture;
 }

 /**
  * Creates a fixture from a shape and attach it to this body.
  * This is a convenience function. Use FixtureDef if you need to set
  * parameters like friction, restitution, user data, or filtering.
  * If the density is non-zero, this function automatically updates the mass
  * of the body.
  */
 Fixture createFixtureFromShape(Shape shape, [num density = 0]) {
   _fixDef.shape = shape;
   _fixDef.density = density;

   return createFixture(_fixDef);
 }

 /**
  * Destroy a fixture. This removes the fixture from the broad-phase and
  * destroys all contacts associated with this fixture. This will
  * automatically adjust the mass of the body if the body is dynamic and the
  * fixture has positive density.
  * All fixtures attached to a body are implicitly destroyed when the body is
  * destroyed.
  */
 void destroyFixture(Fixture fixture) {
   assert (world.locked == false);
   if (world.locked == true) {
     return;
   }

   assert (fixture.body == this);

   // Remove the fixture from this body's singly linked list.
   assert (fixtureCount &gt; 0);
   Fixture node = fixtureList;
   Fixture last = null; // java change
   bool found = false;
   while (node != null) {
     if (node == fixture) {
       node = fixture.next;
       found = true;
       break;
     }
     last = node;
     node = node.next;
   }

   // You tried to remove a shape that is not attached to this body.
   assert (found);

   if (last == null) {
     fixtureList = fixture.next;
   } else {
     last.next = fixture.next;
   }

   // Destroy any contacts associated with the fixture.
   ContactEdge edge = contactList;
   while (edge != null) {
     Contact c = edge.contact;
     edge = edge.next;

     Fixture fixtureA = c.fixtureA;
     Fixture fixtureB = c.fixtureB;

     if (fixture == fixtureA || fixture == fixtureB) {
       // This destroys the contact and removes it from
       // this body's contact list.
       world._contactManager.destroy(c);
     }
   }

   if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
     assert (fixture.proxy != null);
     BroadPhase broadPhase = world._contactManager.broadPhase;
     fixture.destroyProxy(broadPhase);
   } else {
     assert (fixture.proxy == null);
   }

   fixture.destroy();
   fixture.body = null;
   fixture.next = null;
   fixture = null;

   --fixtureCount;

   // Reset the mass data.
   resetMassData();
 }

 /**
  * Set the position of the body's origin and rotation.
  * This breaks any contacts and wakes the other bodies.
  * Manipulating a body's transform may cause non-physical behavior.
  */
 void setTransform(vec2 argPosition, num argAngle) {
   assert (world.locked == false);
   if (world.locked == true) {
     return;
   }

   originTransform.rotation.setRotation(argAngle);
   originTransform.position.copyFrom(argPosition);

   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.copyFrom(sweep.centerZero);

   sweep.angleZero = argAngle;
   sweep.angle = argAngle;

   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     f.synchronize(broadPhase, originTransform, originTransform);
   }

   world._contactManager.findNewContacts();
 }

 /** Get the world body origin position. Do not modify. */
 vec2 get position =&gt; originTransform.position;

 /** Get the angle in radians. */
 num get angle =&gt; sweep.angle;

 /** Get the world position of the center of mass. Do not modify. */
 vec2 get worldCenter =&gt; sweep.center; 

 /** Get the local position of the center of mass. Do not modify. */
 vec2 get localCenter =&gt; sweep.localCenter; 

 vec2 get linearVelocity =&gt; _linearVelocity; 

 void set linearVelocity(vec2 v) {
   if (_type == BodyType.STATIC) {
     return;
   }

   if (dot(v, v) &gt; 0.0) {
     awake = true;
   }

   _linearVelocity.copyFrom(v);
 }

 num get angularVelocity =&gt; _angularVelocity; 

 void set angularVelocity(num w) {
   if (_type != BodyType.STATIC) {

     // Set awake if want to set velocity to non-zero value.
     if (w * w &gt; 0) {
       awake = true;
     }

     _angularVelocity = w;
   }
 }

 /**
  * Apply a force at a world point. If the force is not
  * applied at the center of mass, it will generate a torque and
  * affect the angular velocity. This wakes up the body.
  *
  * force
  *   the world force vector, usually in Newtons (N).
  * point
  *   the world position of the point of application.
  */
 void applyForce(vec2 force, vec2 point) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;

   _force.x += force.x;
   _force.y += force.y;

   _torque += (point.x - sweep.center.x) * force.y - (point.y - sweep.center.y)
       * force.x;
 }

 /**
  * Apply a torque. This affects the angular velocity
  * without affecting the linear velocity of the center of mass.
  * This wakes up the body.
  *
  * torque
  *   about the z-axis (out of the screen), usually in N-m.
  */
 void applyTorque(num torque) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;

   _torque += torque;
 }

 /**
  * Apply an impulse at a point. This immediately modifies the velocity.
  * It also modifies the angular velocity if the point of application
  * is not at the center of mass. This wakes up the body.
  *
  * impulse
  *   the world impulse vector, usually in N-seconds or kg-m/s.
  * point
  *   the world position of the point of application.
  */
 void applyLinearImpulse(vec2 impulse, vec2 point) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;

   _linearVelocity.x += impulse.x * invMass;
   _linearVelocity.y += impulse.y * invMass;

   _angularVelocity += invInertia * ((point.x - sweep.center.x) *
       impulse.y - (point.y - sweep.center.y) * impulse.x);
 }

 /**
  * Apply an angular impulse.
  *
  * impulse
  *   the angular impulse in units of kg*m*m/s
  */
 void applyAngularImpulse(num impulse) {
   if (_type != BodyType.DYNAMIC) {
     return;
   }

   awake = true;
   _angularVelocity += invInertia * impulse;
 }

 /**
  * Get the central rotational inertia of the body.
  *
  * returns the rotational inertia, usually in kg-m^2.
  */
 num get inertia {
   return _inertia + mass * (sweep.localCenter.x * sweep.localCenter.x +
       sweep.localCenter.y * sweep.localCenter.y);
 }

 /**
  * Get the mass data of the body. The rotational inertia is relative
  * to the center of mass. Result is returned through the given out parameter
  * data.
  */
 void getMassData(MassData data) {
   data.mass = mass;
   final vec2 lc = sweep.localCenter;
   data.inertia = _inertia + mass * lc.length2;
   data.center.x = lc.x;
   data.center.y = lc.y;
 }

 /**
  * Set the mass properties to override the mass properties of the fixtures.
  * Note that this changes the center of mass position.
  * Note that creating or destroying fixtures can also alter the mass.
  * This function has no effect if the body isn't dynamic.
  *
  * data
  *   the mass properties.
  */
 void set massData(MassData data) {
   assert(world.locked == false);
   if (world.locked == true) {
     return;
   }

   if (_type != BodyType.DYNAMIC) {
     return;
   }

   invMass = 0.0;
   _inertia = 0.0;
   invInertia = 0.0;

   mass = data.mass;
   if (mass &lt;= 0.0)
     mass = 1;

   invMass = 1.0 / mass;

   if (data.inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
     _inertia = data.inertia - mass * dot(data.center, data.center);
     assert (_inertia &gt; 0.0);
     invInertia = 1.0 / _inertia;
   }

   // Move center of mass.
   oldCenter.copyFrom(sweep.center);
   sweep.localCenter.copyFrom(data.center);
   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.copyFrom(sweep.centerZero);

   // Update center of mass velocity.
   final vec2 temp = sweep.center - oldCenter;
   cross(_angularVelocity, temp, temp);
   _linearVelocity.add(temp);
 }

 /**
  * This resets the mass properties to the sum of the mass properties of the
  * fixtures.
  * This normally does not need to be called unless you called setMassData to
  * override the mass and you later want to reset the mass.
  */
 void resetMassData() {
   // Compute mass data from shapes. Each shape has its own density.
   mass = 0.0;
   invMass = 0.0;
   _inertia = 0.0;
   invInertia = 0.0;
   sweep.localCenter.splat(0.0);

   // Static and kinematic bodies have zero mass.
   if (_type == BodyType.STATIC || _type == BodyType.KINEMATIC) {
     sweep.center.copyFrom(originTransform.position);
     sweep.centerZero.copyFrom(originTransform.position);
     return;
   }

   assert (_type == BodyType.DYNAMIC);

   // Accumulate mass over all fixtures.
   tempCenter.splat(0.0);
   MassData massData = _pmd;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     if (f.density == 0.0) {
       continue;
     }
     f.getMassData(massData);
     mass += massData.mass;
     final temp = new vec2.copy(massData.center);
     temp.scale(massData.mass);
     tempCenter.add(temp);
     _inertia += massData.inertia;
   }

   // Compute center of mass.
   if (mass &gt; 0.0) {
     invMass = 1.0 / mass;
     tempCenter.scale(invMass);
   } else {
     // Force all dynamic bodies to have a positive mass.
     mass = 1.0;
     invMass = 1.0;
   }

   if (_inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
     // Center the inertia about the center of mass.
     _inertia -= mass * dot(tempCenter, tempCenter);
     assert (_inertia &gt; 0.0);
     invInertia = 1.0 / _inertia;
   } else {
     _inertia = 0.0;
     invInertia = 0.0;
   }

   // Move center of mass.
   oldCenter.copyFrom(sweep.center);
   sweep.localCenter.copyFrom(tempCenter);
   Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
   sweep.center.copyFrom(sweep.centerZero);

   // Update center of mass velocity.
   final vec2 temp = sweep.center - oldCenter;
   _linearVelocity.add(cross(_angularVelocity, temp));
 }

 /**
  * Get the world coordinates of a point given the local coordinates.
  *
  * localPoint
  *   a point on the body measured relative the the body's origin.
  * returns the same point expressed in world coordinates.
  */
 vec2 getWorldPoint(vec2 localPoint) {
   vec2 v = new vec2.zero();
   getWorldPointToOut(localPoint, v);
   return v;
 }

 /**
  * Get the world coordinates of a point given the local coordinates to the
  * given out parameter.
  */
 void getWorldPointToOut(vec2 localPoint, vec2 out) {
   Transform.mulToOut(originTransform, localPoint, out);
 }

 /**
  * Get the world coordinates of a vector given the local coordinates.
  *
  * localVector: a vector fixed in the body.
  * return the same vector expressed in world coordinates.
  */
 vec2 getWorldVector(vec2 localVector) {
   vec2 out = new vec2.zero();
   getWorldVectorToOut(localVector, out);
   return out;
 }

 /**
  * Get the world coordinates of a vector given the local coordinates to the
  * given out paramater.
  */
 void getWorldVectorToOut(vec2 localVector, vec2 out) {
   originTransform.rotation.transformed(localVector, out);
 }

 /**
  * Gets a local point relative to the body's origin given a world point.
  * Returns this through the given out parameter.
  */
 void getLocalPointToOut(vec2 worldPoint, vec2 out) {
   Transform.mulTransToOut(originTransform, worldPoint, out);
 }

 /**
  * Gets a local point relative to the body's origin given a world point.
  *
  * worldPoint: point in world coordinates.
  * returns the corresponding local point relative to the body's origin.
  */
 vec2 getLocalPoint(vec2 worldPoint) {
   vec2 out = new vec2.zero();
   getLocalPointToOut(worldPoint, out);
   return out;
 }

 /**
  * Gets a local vector given a world vector.
  *
  * worldVector: vector in world coordinates.
  * returns the corresponding local vector.
  */
 vec2 getLocalVector(vec2 worldVector) {
   vec2 out = new vec2.zero();
   getLocalVectorToOut(worldVector, out);
   return out;
 }

 /**
  * Gets a local vector given a world vector and stores the result in the given
  * out parameter.
  */
 void getLocalVectorToOut(vec2 worldVector, vec2 out) {
   originTransform.rotation.transposed().transformed(worldVector, out);
 }

 /**
  * Get the world linear velocity of a world point attached to this body.
  *
  * worldPoint: point in world coordinates.
  * returns the world velocity of a point.
  */
 vec2 getLinearVelocityFromWorldPoint(vec2 worldPoint) {
   vec2 out = new vec2.zero();
   getLinearVelocityFromWorldPointToOut(worldPoint, out);
   return out;
 }

 void getLinearVelocityFromWorldPointToOut(vec2 worldPoint, vec2 out) {
   out.copyFrom(worldPoint).sub(sweep.center);
   out = cross(_angularVelocity, out);
   out.add(_linearVelocity);
 }

 /**
  * Get the world velocity of a local point.
  *
  * localPoint: point in local coordinates.
  * returns the world velocity of a point.
  */
 vec2 getLinearVelocityFromLocalPoint(vec2 localPoint) {
   vec2 out = new vec2.zero();
   getLinearVelocityFromLocalPointToOut(localPoint, out);
   return out;
 }

 /**
  * Get the world velocity of a local point and store the result in the given
  * out parameter.
  */
 void getLinearVelocityFromLocalPointToOut(vec2 localPoint, vec2 out) {
   getWorldPointToOut(localPoint, out);
   getLinearVelocityFromWorldPointToOut(out, out);
 }

 /**
  * The type of this body. Either dynamic, static, or kinematic.
  */
 int get type =&gt; _type; 

 /**
  * The type of this body. This may alter the mass and velocity.
  */
 void set type(int otherType) {
   if (_type == otherType) {
     return;
   }

   _type = otherType;

   resetMassData();

   if (_type == BodyType.STATIC) {
     _linearVelocity.splat(0.0);
     _angularVelocity = 0.0;
   }

   awake = true;

   _force.splat(0.0);
   _torque = 0.0;

   // Since the body type changed, we need to flag contacts for filtering.
   for (ContactEdge ce = contactList; ce != null; ce = ce.next) {
     ce.contact.flagForFiltering();
   }
 }

 /** Is this body treated like a bullet for continuous collision detection? */
 bool get bullet =&gt; (flags &amp; BULLET_FLAG) == BULLET_FLAG; 

 /**
  * Should this body be treated like a bullet for continuous collision
  * detection?
  */
 void set bullet(bool flag) {
   if (flag)
     flags |= BULLET_FLAG;
   else
     flags &amp;= ~BULLET_FLAG;
 }

 /**
  * You can disable sleeping on this body. If you disable sleeping, the
  * body will be woken.
  */
 void set sleepingAllowed(bool flag) {
   if (flag) {
     flags |= AUTO_SLEEP_FLAG;
   } else {
     flags &amp;= ~AUTO_SLEEP_FLAG;
     awake = true;
   }
 }

 /** Is this body allowed to sleep? */
 bool get sleepingAllowed =&gt; (flags &amp; AUTO_SLEEP_FLAG) == AUTO_SLEEP_FLAG; 

 /**
  * The sleep state of the body. A sleeping body has very
  * low CPU cost.
  */
 void set awake(bool flag) {
   if (flag) {
     if ((flags &amp; AWAKE_FLAG) == 0) {
       flags |= AWAKE_FLAG;
       sleepTime = 0.0;
     }
   } else {
     flags &amp;= ~AWAKE_FLAG;
     sleepTime = 0.0;
     _linearVelocity.splat(0.0);
     _angularVelocity = 0.0;
     _force.splat(0.0);
     _torque = 0.0;
   }
 }

 bool get awake =&gt; (flags &amp; AWAKE_FLAG) == AWAKE_FLAG; 

 /**
  * Set the active state of the body. An inactive body is not
  * simulated and cannot be collided with or woken up.
  * If you pass a flag of true, all fixtures will be added to the
  * broad-phase.
  * If you pass a flag of false, all fixtures will be removed from
  * the broad-phase and all contacts will be destroyed.
  * Fixtures and joints are otherwise unaffected. You may continue
  * to create/destroy fixtures and joints on inactive bodies.
  * Fixtures on an inactive body are implicitly inactive and will
  * not participate in collisions, ray-casts, or queries.
  * Joints connected to an inactive body are implicitly inactive.
  * An inactive body is still owned by a World object and remains
  * in the body list.
  */
 void set active(bool flag) {
   if (flag == active) {
     return;
   }

   if (flag) {
     flags |= ACTIVE_FLAG;

     // Create all proxies.
     BroadPhase broadPhase = world._contactManager.broadPhase;
     for (Fixture f = fixtureList; f != null; f = f.next) {
       f.createProxy(broadPhase, originTransform);
     }

     // Contacts are created the next time step.
   } else {
     flags &amp;= ~ACTIVE_FLAG;

     // Destroy all proxies.
     BroadPhase broadPhase = world._contactManager.broadPhase;
     for (Fixture f = fixtureList; f != null; f = f.next) {
       f.destroyProxy(broadPhase);
     }

     // Destroy the attached contacts.
     ContactEdge ce = contactList;
     while (ce != null) {
       ContactEdge ce0 = ce;
       ce = ce.next;
       world._contactManager.destroy(ce0.contact);
     }
     contactList = null;
   }
 }

 /**
  * Get the active state of the body.
  */
 bool get active =&gt; (flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG; 

 /**
  * Set this body to have fixed rotation. This causes the mass
  * to be reset.
  */
 void set fixedRotation(bool flag) {
   if (flag)
     flags |= FIXED_ROTATION_FLAG;
   else
     flags &amp;= ~FIXED_ROTATION_FLAG;

   resetMassData();
 }

 /**
  * Does this body have fixed rotation?
  */
 bool get fixedRotation {
   return (flags &amp; FIXED_ROTATION_FLAG) == FIXED_ROTATION_FLAG;
 }

 void synchronizeFixtures() {
   final Transform xf1 = _pxf;
   xf1.rotation.setRotation(sweep.angleZero);
   xf1.position.copyFrom(sweep.localCenter);
   xf1.rotation.transform(xf1.position);
   xf1.position.negate().add(sweep.centerZero);

   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next)
     f.synchronize(broadPhase, xf1, originTransform);
 }

 void synchronizeTransform() {
   final Transform t = originTransform;
   final mat2 r = t.rotation;
   final vec2 p = t.position;
   r.setRotation(sweep.angle);
   p.x = (r.col0.x * sweep.localCenter.x + r.col1.x * sweep.localCenter.y) * -1 +
       sweep.center.x;
   p.y = (r.col0.y * sweep.localCenter.x + r.col1.y * sweep.localCenter.y) * -1 +
       sweep.center.y;
 }

 /**
  * This is used to prevent connected bodies from colliding.
  * It may lie, depending on the collideConnected flag.
  */
 bool shouldCollide(Body other) {
   // At least one body should be dynamic.
   return !(_type != BodyType.DYNAMIC &amp;&amp; other._type != BodyType.DYNAMIC);
 }

 void advance(num t) {
   sweep.advance(t);
   sweep.center.copyFrom(sweep.centerZero);
   sweep.angle = sweep.angleZero;
   synchronizeTransform();
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="ACTIVE_FLAG">
<button class="show-code">Code</button>
const int         <strong>ACTIVE_FLAG</strong> <a class="anchor-link"
            href="#ACTIVE_FLAG"
            title="Permalink to Body.ACTIVE_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int ACTIVE_FLAG = 0x0020
</pre>
</div>
</div>
<div class="field"><h4 id="AUTO_SLEEP_FLAG">
<button class="show-code">Code</button>
const int         <strong>AUTO_SLEEP_FLAG</strong> <a class="anchor-link"
            href="#AUTO_SLEEP_FLAG"
            title="Permalink to Body.AUTO_SLEEP_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int AUTO_SLEEP_FLAG = 0x0004
</pre>
</div>
</div>
<div class="field"><h4 id="AWAKE_FLAG">
<button class="show-code">Code</button>
const int         <strong>AWAKE_FLAG</strong> <a class="anchor-link"
            href="#AWAKE_FLAG"
            title="Permalink to Body.AWAKE_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int AWAKE_FLAG = 0x0002
</pre>
</div>
</div>
<div class="field"><h4 id="BULLET_FLAG">
<button class="show-code">Code</button>
const int         <strong>BULLET_FLAG</strong> <a class="anchor-link"
            href="#BULLET_FLAG"
            title="Permalink to Body.BULLET_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int BULLET_FLAG = 0x0008
</pre>
</div>
</div>
<div class="field"><h4 id="FIXED_ROTATION_FLAG">
<button class="show-code">Code</button>
const int         <strong>FIXED_ROTATION_FLAG</strong> <a class="anchor-link"
            href="#FIXED_ROTATION_FLAG"
            title="Permalink to Body.FIXED_ROTATION_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int FIXED_ROTATION_FLAG = 0x0010
</pre>
</div>
</div>
<div class="field"><h4 id="ISLAND_FLAG">
<button class="show-code">Code</button>
const int         <strong>ISLAND_FLAG</strong> <a class="anchor-link"
            href="#ISLAND_FLAG"
            title="Permalink to Body.ISLAND_FLAG">#</a>
        </h4>
        <div class="doc">
<p>Flags for different states the body can take on. </p>
<pre class="source">
static const int ISLAND_FLAG = 0x0001
</pre>
</div>
</div>
<div class="field"><h4 id="TO_I_FLAG">
<button class="show-code">Code</button>
const int         <strong>TO_I_FLAG</strong> <a class="anchor-link"
            href="#TO_I_FLAG"
            title="Permalink to Body.TO_I_FLAG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const int TO_I_FLAG = 0x0040
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Body">
<button class="show-code">Code</button>
new <strong>Body</strong>(<a href="../box2d/BodyDef.html">BodyDef</a> bd, <a href="../box2d/World.html">World</a> world) <a class="anchor-link" href="#Body"
              title="Permalink to Body.Body">#</a></h4>
<div class="doc">
<pre class="source">
Body(BodyDef bd, this.world)
   : flags = 0,
     // Set the origin transform.
     originTransform = new Transform(),

     // Set the sweep.
     sweep = new Sweep(),

     jointList = null,
     contactList = null,
     prev = null,
     next = null,

     // Set the linear and angular velocities.
     _linearVelocity = new vec2.copy(bd.linearVelocity),
     _angularVelocity = 0,

     // Set the linear and angular damping.
     linearDamping = bd.linearDamping,
     angularDamping = bd.angularDamping,

     // Set force and torque.
     _force = new vec2.zero(),
     _torque = 0,

     _inertia = 0,
     invInertia = 0,

     userData = bd.userData,

     fixtureList = null,
     fixtureCount = 0,

     // Initialize pool objects.
     _fixDef = new FixtureDef(),
     _pmd = new MassData(),
     _pxf = new Transform(),
     oldCenter = new vec2.zero(),
     tempCenter = new vec2.zero(),

     sleepTime = 0,

     _type = bd.type {
 if (bd.bullet) {
   flags |= BULLET_FLAG;
 }
 if (bd.fixedRotation) {
   flags |= FIXED_ROTATION_FLAG;
 }
 if (bd.allowSleep) {
   flags |= AUTO_SLEEP_FLAG;
 }
 if (bd.awake) {
   flags |= AWAKE_FLAG;
 }
 if (bd.active) {
   flags |= ACTIVE_FLAG;
 }

 originTransform.position.copyFrom(bd.position);
 originTransform.rotation.setRotation(bd.angle);
 sweep.localCenter.splat(0.0);
 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.copyFrom(sweep.centerZero);
 sweep.angle = bd.angle;
 sweep.angleZero = bd.angle;

 if (_type == BodyType.DYNAMIC) {
   mass = 1;
   invMass = 1;
 } else {
   mass = 0;
   invMass = 0;
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="method"><h4 id="active">
<button class="show-code">Code</button>
bool <strong>get active</strong> <a class="anchor-link" href="#active"
              title="Permalink to Body.get active">#</a></h4>
<div class="doc">
<p>Get the active state of the body.</p>
<pre class="source">
bool get active =&gt; (flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG;
</pre>
</div>
</div>
<div class="method"><h4 id="active=">
<button class="show-code">Code</button>
void <strong>set active</strong>(bool flag) <a class="anchor-link" href="#active="
              title="Permalink to Body.set active">#</a></h4>
<div class="doc">
<p>Set the active state of the body. An inactive body is not
simulated and cannot be collided with or woken up.
If you pass a flag of true, all fixtures will be added to the
broad-phase.
If you pass a flag of false, all fixtures will be removed from
the broad-phase and all contacts will be destroyed.
Fixtures and joints are otherwise unaffected. You may continue
to create/destroy fixtures and joints on inactive bodies.
Fixtures on an inactive body are implicitly inactive and will
not participate in collisions, ray-casts, or queries.
Joints connected to an inactive body are implicitly inactive.
An inactive body is still owned by a World object and remains
in the body list.</p>
<pre class="source">
void set active(bool flag) {
 if (flag == active) {
   return;
 }

 if (flag) {
   flags |= ACTIVE_FLAG;

   // Create all proxies.
   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     f.createProxy(broadPhase, originTransform);
   }

   // Contacts are created the next time step.
 } else {
   flags &amp;= ~ACTIVE_FLAG;

   // Destroy all proxies.
   BroadPhase broadPhase = world._contactManager.broadPhase;
   for (Fixture f = fixtureList; f != null; f = f.next) {
     f.destroyProxy(broadPhase);
   }

   // Destroy the attached contacts.
   ContactEdge ce = contactList;
   while (ce != null) {
     ContactEdge ce0 = ce;
     ce = ce.next;
     world._contactManager.destroy(ce0.contact);
   }
   contactList = null;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="angle">
<button class="show-code">Code</button>
final num         <strong>angle</strong> <a class="anchor-link"
            href="#angle"
            title="Permalink to Body.angle">#</a>
        </h4>
        <div class="doc">
<p>Get the angle in radians. </p>
<pre class="source">
num get angle =&gt; sweep.angle;
</pre>
</div>
</div>
<div class="field"><h4 id="angularDamping">
<button class="show-code">Code</button>
num         <strong>angularDamping</strong> <a class="anchor-link"
            href="#angularDamping"
            title="Permalink to Body.angularDamping">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num angularDamping
</pre>
</div>
</div>
<div class="field"><h4 id="angularVelocity">
<button class="show-code">Code</button>
num         <strong>angularVelocity</strong> <a class="anchor-link"
            href="#angularVelocity"
            title="Permalink to Body.angularVelocity">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num get angularVelocity =&gt; _angularVelocity;
</pre>
<pre class="source">
void set angularVelocity(num w) {
 if (_type != BodyType.STATIC) {

   // Set awake if want to set velocity to non-zero value.
   if (w * w &gt; 0) {
     awake = true;
   }

   _angularVelocity = w;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="awake">
<button class="show-code">Code</button>
bool         <strong>awake</strong> <a class="anchor-link"
            href="#awake"
            title="Permalink to Body.awake">#</a>
        </h4>
        <div class="doc">
<p>The sleep state of the body. A sleeping body has very
low CPU cost.</p>
<pre class="source">
bool get awake =&gt; (flags &amp; AWAKE_FLAG) == AWAKE_FLAG;
</pre>
<pre class="source">
void set awake(bool flag) {
 if (flag) {
   if ((flags &amp; AWAKE_FLAG) == 0) {
     flags |= AWAKE_FLAG;
     sleepTime = 0.0;
   }
 } else {
   flags &amp;= ~AWAKE_FLAG;
   sleepTime = 0.0;
   _linearVelocity.splat(0.0);
   _angularVelocity = 0.0;
   _force.splat(0.0);
   _torque = 0.0;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="bullet">
<button class="show-code">Code</button>
bool <strong>get bullet</strong> <a class="anchor-link" href="#bullet"
              title="Permalink to Body.get bullet">#</a></h4>
<div class="doc">
<p>Is this body treated like a bullet for continuous collision detection? </p>
<pre class="source">
bool get bullet =&gt; (flags &amp; BULLET_FLAG) == BULLET_FLAG;
</pre>
</div>
</div>
<div class="method"><h4 id="bullet=">
<button class="show-code">Code</button>
void <strong>set bullet</strong>(bool flag) <a class="anchor-link" href="#bullet="
              title="Permalink to Body.set bullet">#</a></h4>
<div class="doc">
<p>Should this body be treated like a bullet for continuous collision
detection?</p>
<pre class="source">
void set bullet(bool flag) {
 if (flag)
   flags |= BULLET_FLAG;
 else
   flags &amp;= ~BULLET_FLAG;
}
</pre>
</div>
</div>
<div class="field"><h4 id="contactList">
<button class="show-code">Code</button>
<a href="../box2d/ContactEdge.html">ContactEdge</a>         <strong>contactList</strong> <a class="anchor-link"
            href="#contactList"
            title="Permalink to Body.contactList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
ContactEdge contactList
</pre>
</div>
</div>
<div class="method"><h4 id="fixedRotation">
<button class="show-code">Code</button>
bool <strong>get fixedRotation</strong> <a class="anchor-link" href="#fixedRotation"
              title="Permalink to Body.get fixedRotation">#</a></h4>
<div class="doc">
<p>Does this body have fixed rotation?</p>
<pre class="source">
bool get fixedRotation {
 return (flags &amp; FIXED_ROTATION_FLAG) == FIXED_ROTATION_FLAG;
}
</pre>
</div>
</div>
<div class="method"><h4 id="fixedRotation=">
<button class="show-code">Code</button>
void <strong>set fixedRotation</strong>(bool flag) <a class="anchor-link" href="#fixedRotation="
              title="Permalink to Body.set fixedRotation">#</a></h4>
<div class="doc">
<p>Set this body to have fixed rotation. This causes the mass
to be reset.</p>
<pre class="source">
void set fixedRotation(bool flag) {
 if (flag)
   flags |= FIXED_ROTATION_FLAG;
 else
   flags &amp;= ~FIXED_ROTATION_FLAG;

 resetMassData();
}
</pre>
</div>
</div>
<div class="field"><h4 id="fixtureCount">
<button class="show-code">Code</button>
int         <strong>fixtureCount</strong> <a class="anchor-link"
            href="#fixtureCount"
            title="Permalink to Body.fixtureCount">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int fixtureCount
</pre>
</div>
</div>
<div class="field"><h4 id="fixtureList">
<button class="show-code">Code</button>
<a href="../box2d/Fixture.html">Fixture</a>         <strong>fixtureList</strong> <a class="anchor-link"
            href="#fixtureList"
            title="Permalink to Body.fixtureList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Fixture fixtureList
</pre>
</div>
</div>
<div class="field"><h4 id="flags">
<button class="show-code">Code</button>
int         <strong>flags</strong> <a class="anchor-link"
            href="#flags"
            title="Permalink to Body.flags">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int flags
</pre>
</div>
</div>
<div class="field"><h4 id="inertia">
<button class="show-code">Code</button>
final num         <strong>inertia</strong> <a class="anchor-link"
            href="#inertia"
            title="Permalink to Body.inertia">#</a>
        </h4>
        <div class="doc">
<p>Get the central rotational inertia of the body.</p>
<p>returns the rotational inertia, usually in kg-m^2.</p>
<pre class="source">
num get inertia {
 return _inertia + mass * (sweep.localCenter.x * sweep.localCenter.x +
     sweep.localCenter.y * sweep.localCenter.y);
}
</pre>
</div>
</div>
<div class="field"><h4 id="invInertia">
<button class="show-code">Code</button>
num         <strong>invInertia</strong> <a class="anchor-link"
            href="#invInertia"
            title="Permalink to Body.invInertia">#</a>
        </h4>
        <div class="doc">
<p>The inverse of the intertia about the center of mass. </p>
<pre class="source">
num invInertia
</pre>
</div>
</div>
<div class="field"><h4 id="invMass">
<button class="show-code">Code</button>
num         <strong>invMass</strong> <a class="anchor-link"
            href="#invMass"
            title="Permalink to Body.invMass">#</a>
        </h4>
        <div class="doc">
<p>The inverse of the body mass. </p>
<pre class="source">
num invMass
</pre>
</div>
</div>
<div class="field"><h4 id="islandIndex">
<button class="show-code">Code</button>
int         <strong>islandIndex</strong> <a class="anchor-link"
            href="#islandIndex"
            title="Permalink to Body.islandIndex">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int islandIndex
</pre>
</div>
</div>
<div class="field"><h4 id="jointList">
<button class="show-code">Code</button>
<a href="../box2d/JointEdge.html">JointEdge</a>         <strong>jointList</strong> <a class="anchor-link"
            href="#jointList"
            title="Permalink to Body.jointList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
JointEdge jointList
</pre>
</div>
</div>
<div class="field"><h4 id="linearDamping">
<button class="show-code">Code</button>
num         <strong>linearDamping</strong> <a class="anchor-link"
            href="#linearDamping"
            title="Permalink to Body.linearDamping">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num linearDamping
</pre>
</div>
</div>
<div class="field"><h4 id="linearVelocity">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a>         <strong>linearVelocity</strong> <a class="anchor-link"
            href="#linearVelocity"
            title="Permalink to Body.linearVelocity">#</a>
        </h4>
        <div class="doc">
<pre class="source">
vec2 get linearVelocity =&gt; _linearVelocity;
</pre>
<pre class="source">
void set linearVelocity(vec2 v) {
 if (_type == BodyType.STATIC) {
   return;
 }

 if (dot(v, v) &gt; 0.0) {
   awake = true;
 }

 _linearVelocity.copyFrom(v);
}
</pre>
</div>
</div>
<div class="field"><h4 id="localCenter">
<button class="show-code">Code</button>
final <a href="../vector_math/vec2.html">vec2</a>         <strong>localCenter</strong> <a class="anchor-link"
            href="#localCenter"
            title="Permalink to Body.localCenter">#</a>
        </h4>
        <div class="doc">
<p>Get the local position of the center of mass. Do not modify. </p>
<pre class="source">
vec2 get localCenter =&gt; sweep.localCenter;
</pre>
</div>
</div>
<div class="field"><h4 id="mass">
<button class="show-code">Code</button>
num         <strong>mass</strong> <a class="anchor-link"
            href="#mass"
            title="Permalink to Body.mass">#</a>
        </h4>
        <div class="doc">
<p>This body's mass. </p>
<pre class="source">
num mass
</pre>
</div>
</div>
<div class="method"><h4 id="massData=">
<button class="show-code">Code</button>
void <strong>set massData</strong>(<a href="../box2d/MassData.html">MassData</a> data) <a class="anchor-link" href="#massData="
              title="Permalink to Body.set massData">#</a></h4>
<div class="doc">
<p>Set the mass properties to override the mass properties of the fixtures.
Note that this changes the center of mass position.
Note that creating or destroying fixtures can also alter the mass.
This function has no effect if the body isn't dynamic.</p>
<p>data
  the mass properties.</p>
<pre class="source">
void set massData(MassData data) {
 assert(world.locked == false);
 if (world.locked == true) {
   return;
 }

 if (_type != BodyType.DYNAMIC) {
   return;
 }

 invMass = 0.0;
 _inertia = 0.0;
 invInertia = 0.0;

 mass = data.mass;
 if (mass &lt;= 0.0)
   mass = 1;

 invMass = 1.0 / mass;

 if (data.inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
   _inertia = data.inertia - mass * dot(data.center, data.center);
   assert (_inertia &gt; 0.0);
   invInertia = 1.0 / _inertia;
 }

 // Move center of mass.
 oldCenter.copyFrom(sweep.center);
 sweep.localCenter.copyFrom(data.center);
 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.copyFrom(sweep.centerZero);

 // Update center of mass velocity.
 final vec2 temp = sweep.center - oldCenter;
 cross(_angularVelocity, temp, temp);
 _linearVelocity.add(temp);
}
</pre>
</div>
</div>
<div class="field"><h4 id="next">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a>         <strong>next</strong> <a class="anchor-link"
            href="#next"
            title="Permalink to Body.next">#</a>
        </h4>
        <div class="doc">
<p>For mantaining the linked list of bodies. </p>
<pre class="source">
Body next
</pre>
</div>
</div>
<div class="field"><h4 id="oldCenter">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a>         <strong>oldCenter</strong> <a class="anchor-link"
            href="#oldCenter"
            title="Permalink to Body.oldCenter">#</a>
        </h4>
        <div class="doc">
<pre class="source">
vec2 oldCenter
</pre>
</div>
</div>
<div class="field"><h4 id="originTransform">
<button class="show-code">Code</button>
final <a href="../box2d/Transform.html">Transform</a>         <strong>originTransform</strong> <a class="anchor-link"
            href="#originTransform"
            title="Permalink to Body.originTransform">#</a>
        </h4>
        <div class="doc">
<p>The body origin transform. </p>
<pre class="source">
final Transform originTransform
</pre>
</div>
</div>
<div class="field"><h4 id="position">
<button class="show-code">Code</button>
final <a href="../vector_math/vec2.html">vec2</a>         <strong>position</strong> <a class="anchor-link"
            href="#position"
            title="Permalink to Body.position">#</a>
        </h4>
        <div class="doc">
<p>Get the world body origin position. Do not modify. </p>
<pre class="source">
vec2 get position =&gt; originTransform.position;
</pre>
</div>
</div>
<div class="field"><h4 id="prev">
<button class="show-code">Code</button>
<a href="../box2d/Body.html">Body</a>         <strong>prev</strong> <a class="anchor-link"
            href="#prev"
            title="Permalink to Body.prev">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Body prev
</pre>
</div>
</div>
<div class="method"><h4 id="sleepingAllowed">
<button class="show-code">Code</button>
bool <strong>get sleepingAllowed</strong> <a class="anchor-link" href="#sleepingAllowed"
              title="Permalink to Body.get sleepingAllowed">#</a></h4>
<div class="doc">
<p>Is this body allowed to sleep? </p>
<pre class="source">
bool get sleepingAllowed =&gt; (flags &amp; AUTO_SLEEP_FLAG) == AUTO_SLEEP_FLAG;
</pre>
</div>
</div>
<div class="method"><h4 id="sleepingAllowed=">
<button class="show-code">Code</button>
void <strong>set sleepingAllowed</strong>(bool flag) <a class="anchor-link" href="#sleepingAllowed="
              title="Permalink to Body.set sleepingAllowed">#</a></h4>
<div class="doc">
<p>You can disable sleeping on this body. If you disable sleeping, the
body will be woken.</p>
<pre class="source">
void set sleepingAllowed(bool flag) {
 if (flag) {
   flags |= AUTO_SLEEP_FLAG;
 } else {
   flags &amp;= ~AUTO_SLEEP_FLAG;
   awake = true;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="sleepTime">
<button class="show-code">Code</button>
num         <strong>sleepTime</strong> <a class="anchor-link"
            href="#sleepTime"
            title="Permalink to Body.sleepTime">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num sleepTime
</pre>
</div>
</div>
<div class="field"><h4 id="sweep">
<button class="show-code">Code</button>
final <a href="../box2d/Sweep.html">Sweep</a>         <strong>sweep</strong> <a class="anchor-link"
            href="#sweep"
            title="Permalink to Body.sweep">#</a>
        </h4>
        <div class="doc">
<p>The swept motion for CCD. </p>
<pre class="source">
final Sweep sweep
</pre>
</div>
</div>
<div class="field"><h4 id="tempCenter">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a>         <strong>tempCenter</strong> <a class="anchor-link"
            href="#tempCenter"
            title="Permalink to Body.tempCenter">#</a>
        </h4>
        <div class="doc">
<pre class="source">
vec2 tempCenter
</pre>
</div>
</div>
<div class="method"><h4 id="type">
<button class="show-code">Code</button>
int <strong>get type</strong> <a class="anchor-link" href="#type"
              title="Permalink to Body.get type">#</a></h4>
<div class="doc">
<p>The type of this body. Either dynamic, static, or kinematic.</p>
<pre class="source">
int get type =&gt; _type;
</pre>
</div>
</div>
<div class="method"><h4 id="type=">
<button class="show-code">Code</button>
void <strong>set type</strong>(int otherType) <a class="anchor-link" href="#type="
              title="Permalink to Body.set type">#</a></h4>
<div class="doc">
<p>The type of this body. This may alter the mass and velocity.</p>
<pre class="source">
void set type(int otherType) {
 if (_type == otherType) {
   return;
 }

 _type = otherType;

 resetMassData();

 if (_type == BodyType.STATIC) {
   _linearVelocity.splat(0.0);
   _angularVelocity = 0.0;
 }

 awake = true;

 _force.splat(0.0);
 _torque = 0.0;

 // Since the body type changed, we need to flag contacts for filtering.
 for (ContactEdge ce = contactList; ce != null; ce = ce.next) {
   ce.contact.flagForFiltering();
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="userData">
<button class="show-code">Code</button>
Object         <strong>userData</strong> <a class="anchor-link"
            href="#userData"
            title="Permalink to Body.userData">#</a>
        </h4>
        <div class="doc">
<p>User can store what they want in here. </p>
<pre class="source">
dynamic userData
</pre>
</div>
</div>
<div class="field"><h4 id="world">
<button class="show-code">Code</button>
<a href="../box2d/World.html">World</a>         <strong>world</strong> <a class="anchor-link"
            href="#world"
            title="Permalink to Body.world">#</a>
        </h4>
        <div class="doc">
<pre class="source">
World world
</pre>
</div>
</div>
<div class="field"><h4 id="worldCenter">
<button class="show-code">Code</button>
final <a href="../vector_math/vec2.html">vec2</a>         <strong>worldCenter</strong> <a class="anchor-link"
            href="#worldCenter"
            title="Permalink to Body.worldCenter">#</a>
        </h4>
        <div class="doc">
<p>Get the world position of the center of mass. Do not modify. </p>
<pre class="source">
vec2 get worldCenter =&gt; sweep.center;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="advance">
<button class="show-code">Code</button>
void <strong>advance</strong>(num t) <a class="anchor-link" href="#advance"
              title="Permalink to Body.advance">#</a></h4>
<div class="doc">
<pre class="source">
void advance(num t) {
 sweep.advance(t);
 sweep.center.copyFrom(sweep.centerZero);
 sweep.angle = sweep.angleZero;
 synchronizeTransform();
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyAngularImpulse">
<button class="show-code">Code</button>
void <strong>applyAngularImpulse</strong>(num impulse) <a class="anchor-link" href="#applyAngularImpulse"
              title="Permalink to Body.applyAngularImpulse">#</a></h4>
<div class="doc">
<p>Apply an angular impulse.</p>
<p>impulse
  the angular impulse in units of kg<em>m</em>m/s</p>
<pre class="source">
void applyAngularImpulse(num impulse) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;
 _angularVelocity += invInertia * impulse;
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyForce">
<button class="show-code">Code</button>
void <strong>applyForce</strong>(<a href="../vector_math/vec2.html">vec2</a> force, <a href="../vector_math/vec2.html">vec2</a> point) <a class="anchor-link" href="#applyForce"
              title="Permalink to Body.applyForce">#</a></h4>
<div class="doc">
<p>Apply a force at a world point. If the force is not
applied at the center of mass, it will generate a torque and
affect the angular velocity. This wakes up the body.</p>
<p>force
  the world force vector, usually in Newtons (N).
point
  the world position of the point of application.</p>
<pre class="source">
void applyForce(vec2 force, vec2 point) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;

 _force.x += force.x;
 _force.y += force.y;

 _torque += (point.x - sweep.center.x) * force.y - (point.y - sweep.center.y)
     * force.x;
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyLinearImpulse">
<button class="show-code">Code</button>
void <strong>applyLinearImpulse</strong>(<a href="../vector_math/vec2.html">vec2</a> impulse, <a href="../vector_math/vec2.html">vec2</a> point) <a class="anchor-link" href="#applyLinearImpulse"
              title="Permalink to Body.applyLinearImpulse">#</a></h4>
<div class="doc">
<p>Apply an impulse at a point. This immediately modifies the velocity.
It also modifies the angular velocity if the point of application
is not at the center of mass. This wakes up the body.</p>
<p>impulse
  the world impulse vector, usually in N-seconds or kg-m/s.
point
  the world position of the point of application.</p>
<pre class="source">
void applyLinearImpulse(vec2 impulse, vec2 point) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;

 _linearVelocity.x += impulse.x * invMass;
 _linearVelocity.y += impulse.y * invMass;

 _angularVelocity += invInertia * ((point.x - sweep.center.x) *
     impulse.y - (point.y - sweep.center.y) * impulse.x);
}
</pre>
</div>
</div>
<div class="method"><h4 id="applyTorque">
<button class="show-code">Code</button>
void <strong>applyTorque</strong>(num torque) <a class="anchor-link" href="#applyTorque"
              title="Permalink to Body.applyTorque">#</a></h4>
<div class="doc">
<p>Apply a torque. This affects the angular velocity
without affecting the linear velocity of the center of mass.
This wakes up the body.</p>
<p>torque
  about the z-axis (out of the screen), usually in N-m.</p>
<pre class="source">
void applyTorque(num torque) {
 if (_type != BodyType.DYNAMIC) {
   return;
 }

 awake = true;

 _torque += torque;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createFixture">
<button class="show-code">Code</button>
<a href="../box2d/Fixture.html">Fixture</a> <strong>createFixture</strong>(<a href="../box2d/FixtureDef.html">FixtureDef</a> def) <a class="anchor-link" href="#createFixture"
              title="Permalink to Body.createFixture">#</a></h4>
<div class="doc">
<p>Creates a fixture and attach it to this body. Use this function if you need
to set some fixture parameters, like friction. Otherwise you can create the
fixture directly from a shape.
If the density is non-zero, this function automatically updates the mass
of the body.
Contacts are not created until the next time step.</p>
<pre class="source">
Fixture createFixture(FixtureDef def) {
 assert (world.locked == false);

 Fixture fixture = new Fixture();
 fixture.create(this, def);

 if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
   BroadPhase broadPhase = world._contactManager.broadPhase;
   fixture.createProxy(broadPhase, originTransform);
 }

 fixture.next = fixtureList;
 fixtureList = fixture;
 ++fixtureCount;

 fixture.body = this;

 // Adjust mass properties if needed.
 if (fixture.density &gt; 0.0) {
   resetMassData();
 }

 // Let the world know we have a new fixture. This will cause new contacts
 // to be created at the beginning of the next time step.
 world._flags |= World.NEW_FIXTURE;

 return fixture;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createFixtureFromShape">
<button class="show-code">Code</button>
<a href="../box2d/Fixture.html">Fixture</a> <strong>createFixtureFromShape</strong>(<a href="../box2d/Shape.html">Shape</a> shape, [num density = 0]) <a class="anchor-link" href="#createFixtureFromShape"
              title="Permalink to Body.createFixtureFromShape">#</a></h4>
<div class="doc">
<p>Creates a fixture from a shape and attach it to this body.
This is a convenience function. Use FixtureDef if you need to set
parameters like friction, restitution, user data, or filtering.
If the density is non-zero, this function automatically updates the mass
of the body.</p>
<pre class="source">
Fixture createFixtureFromShape(Shape shape, [num density = 0]) {
 _fixDef.shape = shape;
 _fixDef.density = density;

 return createFixture(_fixDef);
}
</pre>
</div>
</div>
<div class="method"><h4 id="destroyFixture">
<button class="show-code">Code</button>
void <strong>destroyFixture</strong>(<a href="../box2d/Fixture.html">Fixture</a> fixture) <a class="anchor-link" href="#destroyFixture"
              title="Permalink to Body.destroyFixture">#</a></h4>
<div class="doc">
<p>Destroy a fixture. This removes the fixture from the broad-phase and
destroys all contacts associated with this fixture. This will
automatically adjust the mass of the body if the body is dynamic and the
fixture has positive density.
All fixtures attached to a body are implicitly destroyed when the body is
destroyed.</p>
<pre class="source">
void destroyFixture(Fixture fixture) {
 assert (world.locked == false);
 if (world.locked == true) {
   return;
 }

 assert (fixture.body == this);

 // Remove the fixture from this body's singly linked list.
 assert (fixtureCount &gt; 0);
 Fixture node = fixtureList;
 Fixture last = null; // java change
 bool found = false;
 while (node != null) {
   if (node == fixture) {
     node = fixture.next;
     found = true;
     break;
   }
   last = node;
   node = node.next;
 }

 // You tried to remove a shape that is not attached to this body.
 assert (found);

 if (last == null) {
   fixtureList = fixture.next;
 } else {
   last.next = fixture.next;
 }

 // Destroy any contacts associated with the fixture.
 ContactEdge edge = contactList;
 while (edge != null) {
   Contact c = edge.contact;
   edge = edge.next;

   Fixture fixtureA = c.fixtureA;
   Fixture fixtureB = c.fixtureB;

   if (fixture == fixtureA || fixture == fixtureB) {
     // This destroys the contact and removes it from
     // this body's contact list.
     world._contactManager.destroy(c);
   }
 }

 if ((flags &amp; ACTIVE_FLAG) == ACTIVE_FLAG) {
   assert (fixture.proxy != null);
   BroadPhase broadPhase = world._contactManager.broadPhase;
   fixture.destroyProxy(broadPhase);
 } else {
   assert (fixture.proxy == null);
 }

 fixture.destroy();
 fixture.body = null;
 fixture.next = null;
 fixture = null;

 --fixtureCount;

 // Reset the mass data.
 resetMassData();
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromLocalPoint">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a> <strong>getLinearVelocityFromLocalPoint</strong>(<a href="../vector_math/vec2.html">vec2</a> localPoint) <a class="anchor-link" href="#getLinearVelocityFromLocalPoint"
              title="Permalink to Body.getLinearVelocityFromLocalPoint">#</a></h4>
<div class="doc">
<p>Get the world velocity of a local point.</p>
<p>localPoint: point in local coordinates.
returns the world velocity of a point.</p>
<pre class="source">
vec2 getLinearVelocityFromLocalPoint(vec2 localPoint) {
 vec2 out = new vec2.zero();
 getLinearVelocityFromLocalPointToOut(localPoint, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromLocalPointToOut">
<button class="show-code">Code</button>
void <strong>getLinearVelocityFromLocalPointToOut</strong>(<a href="../vector_math/vec2.html">vec2</a> localPoint, <a href="../vector_math/vec2.html">vec2</a> out) <a class="anchor-link" href="#getLinearVelocityFromLocalPointToOut"
              title="Permalink to Body.getLinearVelocityFromLocalPointToOut">#</a></h4>
<div class="doc">
<p>Get the world velocity of a local point and store the result in the given
out parameter.</p>
<pre class="source">
void getLinearVelocityFromLocalPointToOut(vec2 localPoint, vec2 out) {
 getWorldPointToOut(localPoint, out);
 getLinearVelocityFromWorldPointToOut(out, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromWorldPoint">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a> <strong>getLinearVelocityFromWorldPoint</strong>(<a href="../vector_math/vec2.html">vec2</a> worldPoint) <a class="anchor-link" href="#getLinearVelocityFromWorldPoint"
              title="Permalink to Body.getLinearVelocityFromWorldPoint">#</a></h4>
<div class="doc">
<p>Get the world linear velocity of a world point attached to this body.</p>
<p>worldPoint: point in world coordinates.
returns the world velocity of a point.</p>
<pre class="source">
vec2 getLinearVelocityFromWorldPoint(vec2 worldPoint) {
 vec2 out = new vec2.zero();
 getLinearVelocityFromWorldPointToOut(worldPoint, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLinearVelocityFromWorldPointToOut">
<button class="show-code">Code</button>
void <strong>getLinearVelocityFromWorldPointToOut</strong>(<a href="../vector_math/vec2.html">vec2</a> worldPoint, <a href="../vector_math/vec2.html">vec2</a> out) <a class="anchor-link" href="#getLinearVelocityFromWorldPointToOut"
              title="Permalink to Body.getLinearVelocityFromWorldPointToOut">#</a></h4>
<div class="doc">
<pre class="source">
void getLinearVelocityFromWorldPointToOut(vec2 worldPoint, vec2 out) {
 out.copyFrom(worldPoint).sub(sweep.center);
 out = cross(_angularVelocity, out);
 out.add(_linearVelocity);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalPoint">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a> <strong>getLocalPoint</strong>(<a href="../vector_math/vec2.html">vec2</a> worldPoint) <a class="anchor-link" href="#getLocalPoint"
              title="Permalink to Body.getLocalPoint">#</a></h4>
<div class="doc">
<p>Gets a local point relative to the body's origin given a world point.</p>
<p>worldPoint: point in world coordinates.
returns the corresponding local point relative to the body's origin.</p>
<pre class="source">
vec2 getLocalPoint(vec2 worldPoint) {
 vec2 out = new vec2.zero();
 getLocalPointToOut(worldPoint, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalPointToOut">
<button class="show-code">Code</button>
void <strong>getLocalPointToOut</strong>(<a href="../vector_math/vec2.html">vec2</a> worldPoint, <a href="../vector_math/vec2.html">vec2</a> out) <a class="anchor-link" href="#getLocalPointToOut"
              title="Permalink to Body.getLocalPointToOut">#</a></h4>
<div class="doc">
<p>Gets a local point relative to the body's origin given a world point.
Returns this through the given out parameter.</p>
<pre class="source">
void getLocalPointToOut(vec2 worldPoint, vec2 out) {
 Transform.mulTransToOut(originTransform, worldPoint, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalVector">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a> <strong>getLocalVector</strong>(<a href="../vector_math/vec2.html">vec2</a> worldVector) <a class="anchor-link" href="#getLocalVector"
              title="Permalink to Body.getLocalVector">#</a></h4>
<div class="doc">
<p>Gets a local vector given a world vector.</p>
<p>worldVector: vector in world coordinates.
returns the corresponding local vector.</p>
<pre class="source">
vec2 getLocalVector(vec2 worldVector) {
 vec2 out = new vec2.zero();
 getLocalVectorToOut(worldVector, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getLocalVectorToOut">
<button class="show-code">Code</button>
void <strong>getLocalVectorToOut</strong>(<a href="../vector_math/vec2.html">vec2</a> worldVector, <a href="../vector_math/vec2.html">vec2</a> out) <a class="anchor-link" href="#getLocalVectorToOut"
              title="Permalink to Body.getLocalVectorToOut">#</a></h4>
<div class="doc">
<p>Gets a local vector given a world vector and stores the result in the given
out parameter.</p>
<pre class="source">
void getLocalVectorToOut(vec2 worldVector, vec2 out) {
 originTransform.rotation.transposed().transformed(worldVector, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getMassData">
<button class="show-code">Code</button>
void <strong>getMassData</strong>(<a href="../box2d/MassData.html">MassData</a> data) <a class="anchor-link" href="#getMassData"
              title="Permalink to Body.getMassData">#</a></h4>
<div class="doc">
<p>Get the mass data of the body. The rotational inertia is relative
to the center of mass. Result is returned through the given out parameter
data.</p>
<pre class="source">
void getMassData(MassData data) {
 data.mass = mass;
 final vec2 lc = sweep.localCenter;
 data.inertia = _inertia + mass * lc.length2;
 data.center.x = lc.x;
 data.center.y = lc.y;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldPoint">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a> <strong>getWorldPoint</strong>(<a href="../vector_math/vec2.html">vec2</a> localPoint) <a class="anchor-link" href="#getWorldPoint"
              title="Permalink to Body.getWorldPoint">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a point given the local coordinates.</p>
<p>localPoint
  a point on the body measured relative the the body's origin.
returns the same point expressed in world coordinates.</p>
<pre class="source">
vec2 getWorldPoint(vec2 localPoint) {
 vec2 v = new vec2.zero();
 getWorldPointToOut(localPoint, v);
 return v;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldPointToOut">
<button class="show-code">Code</button>
void <strong>getWorldPointToOut</strong>(<a href="../vector_math/vec2.html">vec2</a> localPoint, <a href="../vector_math/vec2.html">vec2</a> out) <a class="anchor-link" href="#getWorldPointToOut"
              title="Permalink to Body.getWorldPointToOut">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a point given the local coordinates to the
given out parameter.</p>
<pre class="source">
void getWorldPointToOut(vec2 localPoint, vec2 out) {
 Transform.mulToOut(originTransform, localPoint, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldVector">
<button class="show-code">Code</button>
<a href="../vector_math/vec2.html">vec2</a> <strong>getWorldVector</strong>(<a href="../vector_math/vec2.html">vec2</a> localVector) <a class="anchor-link" href="#getWorldVector"
              title="Permalink to Body.getWorldVector">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a vector given the local coordinates.</p>
<p>localVector: a vector fixed in the body.
return the same vector expressed in world coordinates.</p>
<pre class="source">
vec2 getWorldVector(vec2 localVector) {
 vec2 out = new vec2.zero();
 getWorldVectorToOut(localVector, out);
 return out;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getWorldVectorToOut">
<button class="show-code">Code</button>
void <strong>getWorldVectorToOut</strong>(<a href="../vector_math/vec2.html">vec2</a> localVector, <a href="../vector_math/vec2.html">vec2</a> out) <a class="anchor-link" href="#getWorldVectorToOut"
              title="Permalink to Body.getWorldVectorToOut">#</a></h4>
<div class="doc">
<p>Get the world coordinates of a vector given the local coordinates to the
given out paramater.</p>
<pre class="source">
void getWorldVectorToOut(vec2 localVector, vec2 out) {
 originTransform.rotation.transformed(localVector, out);
}
</pre>
</div>
</div>
<div class="method"><h4 id="resetMassData">
<button class="show-code">Code</button>
void <strong>resetMassData</strong>() <a class="anchor-link" href="#resetMassData"
              title="Permalink to Body.resetMassData">#</a></h4>
<div class="doc">
<p>This resets the mass properties to the sum of the mass properties of the
fixtures.
This normally does not need to be called unless you called setMassData to
override the mass and you later want to reset the mass.</p>
<pre class="source">
void resetMassData() {
 // Compute mass data from shapes. Each shape has its own density.
 mass = 0.0;
 invMass = 0.0;
 _inertia = 0.0;
 invInertia = 0.0;
 sweep.localCenter.splat(0.0);

 // Static and kinematic bodies have zero mass.
 if (_type == BodyType.STATIC || _type == BodyType.KINEMATIC) {
   sweep.center.copyFrom(originTransform.position);
   sweep.centerZero.copyFrom(originTransform.position);
   return;
 }

 assert (_type == BodyType.DYNAMIC);

 // Accumulate mass over all fixtures.
 tempCenter.splat(0.0);
 MassData massData = _pmd;
 for (Fixture f = fixtureList; f != null; f = f.next) {
   if (f.density == 0.0) {
     continue;
   }
   f.getMassData(massData);
   mass += massData.mass;
   final temp = new vec2.copy(massData.center);
   temp.scale(massData.mass);
   tempCenter.add(temp);
   _inertia += massData.inertia;
 }

 // Compute center of mass.
 if (mass &gt; 0.0) {
   invMass = 1.0 / mass;
   tempCenter.scale(invMass);
 } else {
   // Force all dynamic bodies to have a positive mass.
   mass = 1.0;
   invMass = 1.0;
 }

 if (_inertia &gt; 0.0 &amp;&amp; (flags &amp; FIXED_ROTATION_FLAG) == 0) {
   // Center the inertia about the center of mass.
   _inertia -= mass * dot(tempCenter, tempCenter);
   assert (_inertia &gt; 0.0);
   invInertia = 1.0 / _inertia;
 } else {
   _inertia = 0.0;
   invInertia = 0.0;
 }

 // Move center of mass.
 oldCenter.copyFrom(sweep.center);
 sweep.localCenter.copyFrom(tempCenter);
 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.copyFrom(sweep.centerZero);

 // Update center of mass velocity.
 final vec2 temp = sweep.center - oldCenter;
 _linearVelocity.add(cross(_angularVelocity, temp));
}
</pre>
</div>
</div>
<div class="method"><h4 id="setTransform">
<button class="show-code">Code</button>
void <strong>setTransform</strong>(<a href="../vector_math/vec2.html">vec2</a> argPosition, num argAngle) <a class="anchor-link" href="#setTransform"
              title="Permalink to Body.setTransform">#</a></h4>
<div class="doc">
<p>Set the position of the body's origin and rotation.
This breaks any contacts and wakes the other bodies.
Manipulating a body's transform may cause non-physical behavior.</p>
<pre class="source">
void setTransform(vec2 argPosition, num argAngle) {
 assert (world.locked == false);
 if (world.locked == true) {
   return;
 }

 originTransform.rotation.setRotation(argAngle);
 originTransform.position.copyFrom(argPosition);

 Transform.mulToOut(originTransform, sweep.localCenter, sweep.centerZero);
 sweep.center.copyFrom(sweep.centerZero);

 sweep.angleZero = argAngle;
 sweep.angle = argAngle;

 BroadPhase broadPhase = world._contactManager.broadPhase;
 for (Fixture f = fixtureList; f != null; f = f.next) {
   f.synchronize(broadPhase, originTransform, originTransform);
 }

 world._contactManager.findNewContacts();
}
</pre>
</div>
</div>
<div class="method"><h4 id="shouldCollide">
<button class="show-code">Code</button>
bool <strong>shouldCollide</strong>(<a href="../box2d/Body.html">Body</a> other) <a class="anchor-link" href="#shouldCollide"
              title="Permalink to Body.shouldCollide">#</a></h4>
<div class="doc">
<p>This is used to prevent connected bodies from colliding.
It may lie, depending on the collideConnected flag.</p>
<pre class="source">
bool shouldCollide(Body other) {
 // At least one body should be dynamic.
 return !(_type != BodyType.DYNAMIC &amp;&amp; other._type != BodyType.DYNAMIC);
}
</pre>
</div>
</div>
<div class="method"><h4 id="synchronizeFixtures">
<button class="show-code">Code</button>
void <strong>synchronizeFixtures</strong>() <a class="anchor-link" href="#synchronizeFixtures"
              title="Permalink to Body.synchronizeFixtures">#</a></h4>
<div class="doc">
<pre class="source">
void synchronizeFixtures() {
 final Transform xf1 = _pxf;
 xf1.rotation.setRotation(sweep.angleZero);
 xf1.position.copyFrom(sweep.localCenter);
 xf1.rotation.transform(xf1.position);
 xf1.position.negate().add(sweep.centerZero);

 BroadPhase broadPhase = world._contactManager.broadPhase;
 for (Fixture f = fixtureList; f != null; f = f.next)
   f.synchronize(broadPhase, xf1, originTransform);
}
</pre>
</div>
</div>
<div class="method"><h4 id="synchronizeTransform">
<button class="show-code">Code</button>
void <strong>synchronizeTransform</strong>() <a class="anchor-link" href="#synchronizeTransform"
              title="Permalink to Body.synchronizeTransform">#</a></h4>
<div class="doc">
<pre class="source">
void synchronizeTransform() {
 final Transform t = originTransform;
 final mat2 r = t.rotation;
 final vec2 p = t.position;
 r.setRotation(sweep.angle);
 p.x = (r.col0.x * sweep.localCenter.x + r.col1.x * sweep.localCenter.y) * -1 +
     sweep.center.x;
 p.y = (r.col0.y * sweep.localCenter.x + r.col1.y * sweep.localCenter.y) * -1 +
     sweep.center.y;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
